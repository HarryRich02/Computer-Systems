#===INPUT===

# Take user input
input	IN

#===START===

# Store the current calculator value in x1 and output
start	STO	x1
	OUT
# Check if the current value is 1 by subtracting 1 from it. If it is, the program will halt with no further outputs
	SUB	1
	BRZ	0
# Load 0 and store it in x2
	LDA	0
	STO	x2

#===DIVIDE-BY-2===
# x2 is incremented by 1 and x2 is decremented by 2 each loop. When x1 reaches 0, x2 will store n/2 if even, or (n/2)+1 if odd

# Load x2 and increment it by 1, then store the value back in x2
divide	LDA	x2
	ADD	1
	STO	x2
# Load x1 and decrement it by 2, the store the value back in x1
	LDA	x1
	SUB	2
	STO	x1
# If x1 is 0, the original value was even and x2 now stores the original value divided by 2. As it was even, skip the IF-ODD section
	BRZ	next
# While not fully divided, repeat
	BRP	divide

#===IF-ODD===

# Load x2 ((n/2)+1) and check if it will overflow when multiplied by 3 by subtracting 334 from it. If the calculator is still positive, the value would overflow, so the program halts outputting 0
odd	LDA	x2
	SUB	334
	BRP	overflo

# Load x2 ((n/2)+1), and multiply it by 2 by adding it to itself
	LDA	x2
	ADD	x2
# Subtract 1 from the value (this accounts for the overcounting by the division loop, and the +1 in the formula)
	SUB	1

#===REPEAT===

# If n was even the calculator stores 0 and x2 is n/2, therefore adding x2 makes the calculator value n/2
# If n was odd the calculator stores ((3n+1)/2) -(n/2)+1, so by adding x2 the calculator value will now be (3n+1)/2
next	ADD	x2
# Return to the start
	BR	start

#===HALT===
# Load 0 and then output it as an overflow has occurred
overflo	LDA	0
	OUT
# DAT 0 halts the program when ran, but can also be used to load 0 into the calculator
0	DAT	0

#===VARIABLES===
x1	DAT	0
x2	DAT	0
1	DAT	1
2	DAT	2
334	DAT	334
